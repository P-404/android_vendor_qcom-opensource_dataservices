/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.2.0.v202012010850.
* Used org.franca.core 0.13.1.201807231814.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef V0_COM_QUALCOMM_QTI_MODEM_RADIO_SVC_HPP_
#define V0_COM_QUALCOMM_QTI_MODEM_RADIO_SVC_HPP_




#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#define HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>

#if defined (HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE)
#undef COMMONAPI_INTERNAL_COMPILATION
#undef HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE
#endif

namespace v0 {
namespace com {
namespace qualcomm {
namespace qti {
namespace modem {

class RadioSvc {
public:
    virtual ~RadioSvc() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    /*
     * description: 
     * RAT bitmask
     */
    typedef uint32_t RatBitMask;
    
    struct Rat : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            RAT_UNKNOWN = 0,
            RAT_GSM = 1,
            RAT_GPRS = 2,
            RAT_EDGE = 3,
            RAT_EHRPD = 4,
            RAT_UMTS = 5,
            RAT_HSPA = 6,
            RAT_HSDPA = 7,
            RAT_HSUPA = 8,
            RAT_HSPAP = 9,
            RAT_TDSCDMA = 10,
            RAT_LTE = 11,
            RAT_LTE_CA = 12,
            RAT_NR5G = 13
        };
    
        Rat()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::RAT_UNKNOWN)) {}
        Rat(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::RAT_UNKNOWN):
                case static_cast< uint32_t>(Literal::RAT_GSM):
                case static_cast< uint32_t>(Literal::RAT_GPRS):
                case static_cast< uint32_t>(Literal::RAT_EDGE):
                case static_cast< uint32_t>(Literal::RAT_EHRPD):
                case static_cast< uint32_t>(Literal::RAT_UMTS):
                case static_cast< uint32_t>(Literal::RAT_HSPA):
                case static_cast< uint32_t>(Literal::RAT_HSDPA):
                case static_cast< uint32_t>(Literal::RAT_HSUPA):
                case static_cast< uint32_t>(Literal::RAT_HSPAP):
                case static_cast< uint32_t>(Literal::RAT_TDSCDMA):
                case static_cast< uint32_t>(Literal::RAT_LTE):
                case static_cast< uint32_t>(Literal::RAT_LTE_CA):
                case static_cast< uint32_t>(Literal::RAT_NR5G):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Rat &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Rat &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Rat &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Rat &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Rat &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Rat &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::RAT_UNKNOWN): return "RAT_UNKNOWN";
            case static_cast< uint32_t>(Literal::RAT_GSM): return "RAT_GSM";
            case static_cast< uint32_t>(Literal::RAT_GPRS): return "RAT_GPRS";
            case static_cast< uint32_t>(Literal::RAT_EDGE): return "RAT_EDGE";
            case static_cast< uint32_t>(Literal::RAT_EHRPD): return "RAT_EHRPD";
            case static_cast< uint32_t>(Literal::RAT_UMTS): return "RAT_UMTS";
            case static_cast< uint32_t>(Literal::RAT_HSPA): return "RAT_HSPA";
            case static_cast< uint32_t>(Literal::RAT_HSDPA): return "RAT_HSDPA";
            case static_cast< uint32_t>(Literal::RAT_HSUPA): return "RAT_HSUPA";
            case static_cast< uint32_t>(Literal::RAT_HSPAP): return "RAT_HSPAP";
            case static_cast< uint32_t>(Literal::RAT_TDSCDMA): return "RAT_TDSCDMA";
            case static_cast< uint32_t>(Literal::RAT_LTE): return "RAT_LTE";
            case static_cast< uint32_t>(Literal::RAT_LTE_CA): return "RAT_LTE_CA";
            case static_cast< uint32_t>(Literal::RAT_NR5G): return "RAT_NR5G";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct NetRegState : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            NET_REG_STATE_NONE = 0,
            NET_REG_STATE_HOME = 1,
            NET_REG_STATE_SEARCHING = 2,
            NET_REG_STATE_DENIED = 3,
            NET_REG_STATE_ROAMING = 4,
            NET_REG_STATE_UNKNOWN = 5,
            NET_REG_STATE_EMERGENCY_AVAILABLE = 6
        };
    
        NetRegState()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::NET_REG_STATE_NONE)) {}
        NetRegState(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::NET_REG_STATE_NONE):
                case static_cast< uint32_t>(Literal::NET_REG_STATE_HOME):
                case static_cast< uint32_t>(Literal::NET_REG_STATE_SEARCHING):
                case static_cast< uint32_t>(Literal::NET_REG_STATE_DENIED):
                case static_cast< uint32_t>(Literal::NET_REG_STATE_ROAMING):
                case static_cast< uint32_t>(Literal::NET_REG_STATE_UNKNOWN):
                case static_cast< uint32_t>(Literal::NET_REG_STATE_EMERGENCY_AVAILABLE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const NetRegState &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const NetRegState &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const NetRegState &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const NetRegState &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const NetRegState &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const NetRegState &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::NET_REG_STATE_NONE): return "NET_REG_STATE_NONE";
            case static_cast< uint32_t>(Literal::NET_REG_STATE_HOME): return "NET_REG_STATE_HOME";
            case static_cast< uint32_t>(Literal::NET_REG_STATE_SEARCHING): return "NET_REG_STATE_SEARCHING";
            case static_cast< uint32_t>(Literal::NET_REG_STATE_DENIED): return "NET_REG_STATE_DENIED";
            case static_cast< uint32_t>(Literal::NET_REG_STATE_ROAMING): return "NET_REG_STATE_ROAMING";
            case static_cast< uint32_t>(Literal::NET_REG_STATE_UNKNOWN): return "NET_REG_STATE_UNKNOWN";
            case static_cast< uint32_t>(Literal::NET_REG_STATE_EMERGENCY_AVAILABLE): return "NET_REG_STATE_EMERGENCY_AVAILABLE";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct NRDcnrRestriction : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            NR_DCNR_UNKNOWN = 0,
            NR_DCNR_RESTRICTED = 1,
            NR_DCNR_UNRESTRICTED = 2
        };
    
        NRDcnrRestriction()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::NR_DCNR_UNKNOWN)) {}
        NRDcnrRestriction(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::NR_DCNR_UNKNOWN):
                case static_cast< uint32_t>(Literal::NR_DCNR_RESTRICTED):
                case static_cast< uint32_t>(Literal::NR_DCNR_UNRESTRICTED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const NRDcnrRestriction &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const NRDcnrRestriction &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const NRDcnrRestriction &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const NRDcnrRestriction &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const NRDcnrRestriction &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const NRDcnrRestriction &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::NR_DCNR_UNKNOWN): return "NR_DCNR_UNKNOWN";
            case static_cast< uint32_t>(Literal::NR_DCNR_RESTRICTED): return "NR_DCNR_RESTRICTED";
            case static_cast< uint32_t>(Literal::NR_DCNR_UNRESTRICTED): return "NR_DCNR_UNRESTRICTED";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct States : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            OFF = 0,
            UNAVAILABLE = 1,
            ON = 2
        };
    
        States()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::OFF)) {}
        States(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::OFF):
                case static_cast< uint32_t>(Literal::UNAVAILABLE):
                case static_cast< uint32_t>(Literal::ON):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const States &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const States &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const States &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const States &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const States &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const States &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::OFF): return "OFF";
            case static_cast< uint32_t>(Literal::UNAVAILABLE): return "UNAVAILABLE";
            case static_cast< uint32_t>(Literal::ON): return "ON";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct CellInfoStatus : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            CELL_SERVING_CHANGED = 0,
            CELL_NEIGHBOR_CHANGED = 1,
            CELL_SERVING_AND_NEIGHBOR_CHANGED = 2
        };
    
        CellInfoStatus()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::CELL_SERVING_CHANGED)) {}
        CellInfoStatus(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::CELL_SERVING_CHANGED):
                case static_cast< uint32_t>(Literal::CELL_NEIGHBOR_CHANGED):
                case static_cast< uint32_t>(Literal::CELL_SERVING_AND_NEIGHBOR_CHANGED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const CellInfoStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const CellInfoStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const CellInfoStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const CellInfoStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const CellInfoStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const CellInfoStatus &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::CELL_SERVING_CHANGED): return "CELL_SERVING_CHANGED";
            case static_cast< uint32_t>(Literal::CELL_NEIGHBOR_CHANGED): return "CELL_NEIGHBOR_CHANGED";
            case static_cast< uint32_t>(Literal::CELL_SERVING_AND_NEIGHBOR_CHANGED): return "CELL_SERVING_AND_NEIGHBOR_CHANGED";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct SigType : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            SIG_TYPE_GSM_RSSI = 0,
            SIG_TYPE_UMTS_RSSI = 1,
            SIG_TYPE_LTE_RSRP = 2,
            SIG_TYPE_NR5G_RSRP = 3
        };
    
        SigType()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::SIG_TYPE_GSM_RSSI)) {}
        SigType(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::SIG_TYPE_GSM_RSSI):
                case static_cast< uint32_t>(Literal::SIG_TYPE_UMTS_RSSI):
                case static_cast< uint32_t>(Literal::SIG_TYPE_LTE_RSRP):
                case static_cast< uint32_t>(Literal::SIG_TYPE_NR5G_RSRP):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SigType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SigType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SigType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SigType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SigType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SigType &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::SIG_TYPE_GSM_RSSI): return "SIG_TYPE_GSM_RSSI";
            case static_cast< uint32_t>(Literal::SIG_TYPE_UMTS_RSSI): return "SIG_TYPE_UMTS_RSSI";
            case static_cast< uint32_t>(Literal::SIG_TYPE_LTE_RSRP): return "SIG_TYPE_LTE_RSRP";
            case static_cast< uint32_t>(Literal::SIG_TYPE_NR5G_RSRP): return "SIG_TYPE_NR5G_RSRP";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct SigIndicationType : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            SIG_THRESHOLD = 0,
            SIG_DELTA = 1
        };
    
        SigIndicationType()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::SIG_THRESHOLD)) {}
        SigIndicationType(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::SIG_THRESHOLD):
                case static_cast< uint32_t>(Literal::SIG_DELTA):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SigIndicationType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SigIndicationType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SigIndicationType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SigIndicationType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SigIndicationType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SigIndicationType &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::SIG_THRESHOLD): return "SIG_THRESHOLD";
            case static_cast< uint32_t>(Literal::SIG_DELTA): return "SIG_DELTA";
            default: return "UNDEFINED";
            }
        }
    };
    /*
     * description: 
     * GSM signal metrics.
     */
    struct GsmSignalMetrics : CommonAPI::Struct< int32_t, uint32_t> {
    
        GsmSignalMetrics()
        {
            std::get< 0>(values_) = 0;
            std::get< 1>(values_) = 0ul;
        }
        GsmSignalMetrics(const int32_t &_rssi, const uint32_t &_ber)
        {
            std::get< 0>(values_) = _rssi;
            std::get< 1>(values_) = _ber;
        }
        inline const int32_t &getRssi() const { return std::get< 0>(values_); }
        inline void setRssi(const int32_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint32_t &getBer() const { return std::get< 1>(values_); }
        inline void setBer(const uint32_t &_value) { std::get< 1>(values_) = _value; }
        inline bool operator==(const GsmSignalMetrics& _other) const {
        return (getRssi() == _other.getRssi() && getBer() == _other.getBer());
        }
        inline bool operator!=(const GsmSignalMetrics &_other) const {
            return !((*this) == _other);
        }
    
    };
    /*
     * description: 
     * Umts signal metrics.
     */
    struct UmtsSignalMetrics : CommonAPI::Struct< int32_t, uint32_t, int32_t> {
    
        UmtsSignalMetrics()
        {
            std::get< 0>(values_) = 0;
            std::get< 1>(values_) = 0ul;
            std::get< 2>(values_) = 0;
        }
        UmtsSignalMetrics(const int32_t &_ss, const uint32_t &_ber, const int32_t &_rscp)
        {
            std::get< 0>(values_) = _ss;
            std::get< 1>(values_) = _ber;
            std::get< 2>(values_) = _rscp;
        }
        inline const int32_t &getSs() const { return std::get< 0>(values_); }
        inline void setSs(const int32_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint32_t &getBer() const { return std::get< 1>(values_); }
        inline void setBer(const uint32_t &_value) { std::get< 1>(values_) = _value; }
        inline const int32_t &getRscp() const { return std::get< 2>(values_); }
        inline void setRscp(const int32_t &_value) { std::get< 2>(values_) = _value; }
        inline bool operator==(const UmtsSignalMetrics& _other) const {
        return (getSs() == _other.getSs() && getBer() == _other.getBer() && getRscp() == _other.getRscp());
        }
        inline bool operator!=(const UmtsSignalMetrics &_other) const {
            return !((*this) == _other);
        }
    
    };
    /*
     * description: 
     * Lte signal metrics.
     */
    struct LteSignalMetrics : CommonAPI::Struct< int32_t, int32_t, int32_t, int32_t> {
    
        LteSignalMetrics()
        {
            std::get< 0>(values_) = 0;
            std::get< 1>(values_) = 0;
            std::get< 2>(values_) = 0;
            std::get< 3>(values_) = 0;
        }
        LteSignalMetrics(const int32_t &_ss, const int32_t &_rsrq, const int32_t &_rsrp, const int32_t &_snr)
        {
            std::get< 0>(values_) = _ss;
            std::get< 1>(values_) = _rsrq;
            std::get< 2>(values_) = _rsrp;
            std::get< 3>(values_) = _snr;
        }
        inline const int32_t &getSs() const { return std::get< 0>(values_); }
        inline void setSs(const int32_t &_value) { std::get< 0>(values_) = _value; }
        inline const int32_t &getRsrq() const { return std::get< 1>(values_); }
        inline void setRsrq(const int32_t &_value) { std::get< 1>(values_) = _value; }
        inline const int32_t &getRsrp() const { return std::get< 2>(values_); }
        inline void setRsrp(const int32_t &_value) { std::get< 2>(values_) = _value; }
        inline const int32_t &getSnr() const { return std::get< 3>(values_); }
        inline void setSnr(const int32_t &_value) { std::get< 3>(values_) = _value; }
        inline bool operator==(const LteSignalMetrics& _other) const {
        return (getSs() == _other.getSs() && getRsrq() == _other.getRsrq() && getRsrp() == _other.getRsrp() && getSnr() == _other.getSnr());
        }
        inline bool operator!=(const LteSignalMetrics &_other) const {
            return !((*this) == _other);
        }
    
    };
    /*
     * description: 
     * Nr5g signal metrics.
     */
    struct Nr5gSignalMetrics : CommonAPI::Struct< int32_t, int32_t, int32_t> {
    
        Nr5gSignalMetrics()
        {
            std::get< 0>(values_) = 0;
            std::get< 1>(values_) = 0;
            std::get< 2>(values_) = 0;
        }
        Nr5gSignalMetrics(const int32_t &_rsrq, const int32_t &_rsrp, const int32_t &_snr)
        {
            std::get< 0>(values_) = _rsrq;
            std::get< 1>(values_) = _rsrp;
            std::get< 2>(values_) = _snr;
        }
        inline const int32_t &getRsrq() const { return std::get< 0>(values_); }
        inline void setRsrq(const int32_t &_value) { std::get< 0>(values_) = _value; }
        inline const int32_t &getRsrp() const { return std::get< 1>(values_); }
        inline void setRsrp(const int32_t &_value) { std::get< 1>(values_) = _value; }
        inline const int32_t &getSnr() const { return std::get< 2>(values_); }
        inline void setSnr(const int32_t &_value) { std::get< 2>(values_) = _value; }
        inline bool operator==(const Nr5gSignalMetrics& _other) const {
        return (getRsrq() == _other.getRsrq() && getRsrp() == _other.getRsrp() && getSnr() == _other.getSnr());
        }
        inline bool operator!=(const Nr5gSignalMetrics &_other) const {
            return !((*this) == _other);
        }
    
    };
    /*
     * description: 
     * Signal strength indication structure.
     */
    struct SigStrengthIndication : CommonAPI::Struct< SigIndicationType, int32_t, int32_t, uint16_t> {
    
        SigStrengthIndication()
        {
            std::get< 0>(values_) = SigIndicationType();
            std::get< 1>(values_) = 0;
            std::get< 2>(values_) = 0;
            std::get< 3>(values_) = 0u;
        }
        SigStrengthIndication(const SigIndicationType &_type, const int32_t &_lowerRange, const int32_t &_upperRange, const uint16_t &_delta)
        {
            std::get< 0>(values_) = _type;
            std::get< 1>(values_) = _lowerRange;
            std::get< 2>(values_) = _upperRange;
            std::get< 3>(values_) = _delta;
        }
        inline const SigIndicationType &getType() const { return std::get< 0>(values_); }
        inline void setType(const SigIndicationType &_value) { std::get< 0>(values_) = _value; }
        inline const int32_t &getLowerRange() const { return std::get< 1>(values_); }
        inline void setLowerRange(const int32_t &_value) { std::get< 1>(values_) = _value; }
        inline const int32_t &getUpperRange() const { return std::get< 2>(values_); }
        inline void setUpperRange(const int32_t &_value) { std::get< 2>(values_) = _value; }
        inline const uint16_t &getDelta() const { return std::get< 3>(values_); }
        inline void setDelta(const uint16_t &_value) { std::get< 3>(values_) = _value; }
        inline bool operator==(const SigStrengthIndication& _other) const {
        return (getType() == _other.getType() && getLowerRange() == _other.getLowerRange() && getUpperRange() == _other.getUpperRange() && getDelta() == _other.getDelta());
        }
        inline bool operator!=(const SigStrengthIndication &_other) const {
            return !((*this) == _other);
        }
    
    };
    /*
     * description: 
     * Signal strength reporting hysteresis structure.
     */
    struct SigStrengthHysteresis : CommonAPI::Struct< bool, uint16_t, bool, uint16_t> {
    
        SigStrengthHysteresis()
        {
            std::get< 0>(values_) = false;
            std::get< 1>(values_) = 0u;
            std::get< 2>(values_) = false;
            std::get< 3>(values_) = 0u;
        }
        SigStrengthHysteresis(const bool &_setThreshold, const uint16_t &_threshold, const bool &_setTimer, const uint16_t &_timer)
        {
            std::get< 0>(values_) = _setThreshold;
            std::get< 1>(values_) = _threshold;
            std::get< 2>(values_) = _setTimer;
            std::get< 3>(values_) = _timer;
        }
        inline const bool &getSetThreshold() const { return std::get< 0>(values_); }
        inline void setSetThreshold(const bool _value) { std::get< 0>(values_) = _value; }
        inline const uint16_t &getThreshold() const { return std::get< 1>(values_); }
        inline void setThreshold(const uint16_t &_value) { std::get< 1>(values_) = _value; }
        inline const bool &getSetTimer() const { return std::get< 2>(values_); }
        inline void setSetTimer(const bool _value) { std::get< 2>(values_) = _value; }
        inline const uint16_t &getTimer() const { return std::get< 3>(values_); }
        inline void setTimer(const uint16_t &_value) { std::get< 3>(values_) = _value; }
        inline bool operator==(const SigStrengthHysteresis& _other) const {
        return (getSetThreshold() == _other.getSetThreshold() && getThreshold() == _other.getThreshold() && getSetTimer() == _other.getSetTimer() && getTimer() == _other.getTimer());
        }
        inline bool operator!=(const SigStrengthHysteresis &_other) const {
            return !((*this) == _other);
        }
    
    };
    /*
     * description: 
     * Signal metrics for each rat
     */
    typedef CommonAPI::Variant< GsmSignalMetrics, UmtsSignalMetrics, LteSignalMetrics, Nr5gSignalMetrics>  SignalMetrics;
    const uint32_t RAT_BIT_MASK_GSM = 1;
    const uint32_t RAT_BIT_MASK_UMTS = 2;
    const uint32_t RAT_BIT_MASK_CDMA = 4;
    const uint32_t RAT_BIT_MASK_TDSCDMA = 8;
    const uint32_t RAT_BIT_MASK_LTE = 16;
    const uint32_t RAT_BIT_MASK_NR5G = 32;
    const uint32_t RAT_BIT_MASK_ALL = 64;
};

const char* RadioSvc::getInterface() {
    return ("com.qualcomm.qti.modem.RadioSvc:v0_1");
}

CommonAPI::Version RadioSvc::getInterfaceVersion() {
    return CommonAPI::Version(0, 1);
}

/*
 * description: 
 * RAT bitmask
 */
/*
 * description: 
 * Type to represent different RATs supported by the system
 */
/*
 * description: 
 * Network registration state
 */
/*
 * description: 
 * DCNR(Dual Connectivity with NR) Restriction status on 5G NR
 */
/*
 * description: 
 * Radio status enum
 */
/*
 * description: 
 * Cell Info change status enum
 */
/*
 * description: 
 * Signal type enum
 */
/*
 * description: 
 * Signal strength indication type enum
 */
/*
 * description: 
 * GSM signal metrics.
 */
/*
 * description: 
 * Umts signal metrics.
 */
/*
 * description: 
 * Lte signal metrics.
 */
/*
 * description: 
 * Nr5g signal metrics.
 */
/*
 * description: 
 * Signal strength indication structure.
 */
/*
 * description: 
 * Signal strength reporting hysteresis structure.
 */
/*
 * description: 
 * Signal metrics for each rat
 */

} // namespace modem
} // namespace qti
} // namespace qualcomm
} // namespace com
} // namespace v0

namespace CommonAPI {
}


// Compatibility
namespace v0_1 = v0;

#endif // V0_COM_QUALCOMM_QTI_MODEM_RADIO_SVC_HPP_
